# Try

В этой задаче вам предстоит реализовать класс `Try<T>`, содержащий внутри себя либо значение типа `T`, либо объект-ошибку, либо ничего,
а также функцию `TryRun`, которая запускает переданную ей функцию и возвращает `Try<T>`, при необходимости поймав исключение.

Класс `Try<T>` должен содержать следующее:

* Конструктор по умолчанию (это означает, что объект пустой).
* Конструктор(ы), принимающий объект типа T. Для lvalue аргумента должно происходить копирование объекта,
  для rvalue - перемещение.
* Конструктор(ы), принимающий два аргумета:
    * Тег типа `tag::Exception`, обозначающий, что мы хотим сохранить ошибку.
    * Объект-ошибка произвольного типа. Для lvalue аргумента должно происходить копирование объекта, для
      rvalue - перемещение.
* Константный метод `Value`, возвращающий `const T&`. Если в классе было сохранено какое-то исключение, метод должен бросить его.
Если же класс пустой, то метод также должен бросить любое исключение, производное от `std::exception` с текстом "Object is empty".
* Метод `Throw`, который бросает сохраненное исключение. Если же такого нет, то бросает исключение, производное от `std::exception` с
текстом "No exception".
* Константный метод `IsFailed`, который возвращает `true`, если в объекте сохранено какое-то исключение.

Для простоты от вас не требуется реализовывать логику копирования / перемещения объектов
  типа `Try<T>`. Запретите соответствующие конструкторы и операторы присваивания.

Помимо этого в вашем решении должна быть отдельная специализация `Try<void>`, которая не содержит метода `Value` и соответствующего
конструктора.

Реализуйте также функцию-обертку `TryRun`, приведенную в `try.h`. Данная функция запускает переданную функцию с переданными аргументами,
возвращая `Try<T>` в качестве результата. При этом:

* `T` совпадает с возвращаемым типом обернутой функции (в коде вы можете увидеть, как можно определить этот возвращаемый тип).
* Если функция бросила исключение, то:
    * Если это исключение, производное от `std::exception`, то его нужно сохранить в `Try`, при этом когда `Try` попросят бросить
    это исключение (например, через `Throw`), она должна бросить объект того же типа,
    что был пойман в `TryRun`. Для реализации вам понадобится класс
[std::exception_ptr](https://en.cppreference.com/w/cpp/error/exception_ptr).
    * Если это `const char *`, то необходимо запомнить исключение, производное от `std::exception`,
      с данным текстом ошибки.
    * Если это `int`, то мы считаем, что это код системной ошибки.
      [Сохраните](https://stackoverflow.com/questions/12171377/how-to-convert-errno-to-exception-using-system-error)
      `std::system_error` с данным кодом ошибки.
    * Иначе в `Try` нужно сохранить произвольный `std::exception` с текстом "Unknown exception".

### Примечания

* Обратите внимание, что `TryRun` может принимать произвольное число аргументов. Для этого используются variadic templates.
В решении делать с ними ничего помимо `func(std::forward<Args>(args)...)` не нужно.
* Для хранения состояния `Try<T>` хорошо подойдёт [std::variant](https://en.cppreference.com/w/cpp/utility/variant)
